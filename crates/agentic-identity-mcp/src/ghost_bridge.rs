//! Ghost Writer Bridge — Syncs identity context to AI coding assistants.
//!
//! Detects Claude Code, Cursor, Windsurf, and Cody, then writes an
//! identity context summary to each client's memory directory.
//!
//! Called from the stdio loop after each request (synchronous — no background thread).

use std::io::Write;
use std::path::{Path, PathBuf};
use std::time::SystemTime;

/// Cached client directories (detected once, reused on each sync).
pub(crate) struct GhostBridge {
    clients: Vec<ClientDir>,
    last_content_hash: u64,
}

struct ClientDir {
    name: &'static str,
    dir: PathBuf,
    filename: String,
}

impl GhostBridge {
    /// Create and detect all AI clients. Returns None if none found.
    pub(crate) fn new() -> Option<Self> {
        let clients = detect_all_memory_dirs();
        if clients.is_empty() {
            return None;
        }
        for c in &clients {
            eprintln!("[ghost_bridge] Identity context: {} at {:?}", c.name, c.dir);
        }
        Some(Self {
            clients,
            last_content_hash: 0,
        })
    }

    /// Sync current server state to all detected clients.
    /// Only writes if content has changed (dedup via simple hash).
    pub(crate) fn sync(&mut self, server: &super::McpServer) {
        let markdown = build_identity_context(server);

        // Simple dedup: skip write if content hasn't changed
        let hash = simple_hash(&markdown);
        if hash == self.last_content_hash {
            return;
        }
        self.last_content_hash = hash;

        for client in &self.clients {
            let target = client.dir.join(&client.filename);
            if let Err(e) = atomic_write(&target, markdown.as_bytes()) {
                eprintln!("[ghost_bridge] Failed to sync to {:?}: {e}", target);
            }
        }
    }
}

fn build_identity_context(server: &super::McpServer) -> String {
    let now = now_utc_string();

    let mut md = String::new();
    md.push_str("# AgenticIdentity Context\n\n");
    md.push_str(&format!("> Auto-synced by Ghost Writer at {now}\n\n"));

    // Identity store summary
    let id_count = count_files(&server.identity_dir);
    let receipt_count = count_files(&server.receipt_dir);
    let trust_count = count_files(&server.trust_dir);
    let spawn_count = count_files(&server.spawn_dir);

    md.push_str("## Store Summary\n\n");
    md.push_str(&format!(
        "| Store | Count |\n|-------|-------|\n| Identities | {id_count} |\n| Receipts | {receipt_count} |\n| Trust Grants | {trust_count} |\n| Spawns | {spawn_count} |\n\n"
    ));

    // Recent operations (with intent context)
    if !server.operation_log.is_empty() {
        md.push_str("## Recent Operations\n\n");
        for record in server.operation_log.iter().rev().take(15) {
            let summary = if record.summary.len() > 150 {
                format!("{}...", &record.summary[..150])
            } else {
                record.summary.clone()
            };
            let intent_tag = record
                .intent
                .as_deref()
                .map(|i| {
                    let preview = if i.len() > 80 {
                        format!("{}...", &i[..80])
                    } else {
                        i.to_string()
                    };
                    format!(" _{preview}_")
                })
                .unwrap_or_default();
            md.push_str(&format!("- `{}`{} — {summary}\n", record.tool_name, intent_tag));
        }
        md.push('\n');
    }

    md.push_str("---\n");
    md.push_str("_Auto-generated by AgenticIdentity. Do not edit manually._\n");
    md
}

fn count_files(dir: &Path) -> usize {
    std::fs::read_dir(dir)
        .map(|entries| entries.filter(|e| e.is_ok()).count())
        .unwrap_or(0)
}

fn simple_hash(s: &str) -> u64 {
    // FNV-1a hash
    let mut hash: u64 = 0xcbf29ce484222325;
    for byte in s.bytes() {
        hash ^= byte as u64;
        hash = hash.wrapping_mul(0x100000001b3);
    }
    hash
}

// ═══════════════════════════════════════════════════════════════════
// Std-only UTC timestamp (avoids chrono dependency)
// ═══════════════════════════════════════════════════════════════════

fn now_utc_string() -> String {
    let secs = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    let s = secs % 60;
    let min = (secs / 60) % 60;
    let h = (secs / 3600) % 24;
    // Howard Hinnant's civil_from_days algorithm
    let z = (secs / 86400) as i64 + 719468;
    let era = if z >= 0 { z } else { z - 146096 } / 146097;
    let doe = (z - era * 146097) as u64;
    let yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;
    let y = yoe as i64 + era * 400;
    let doy = doe - (365 * yoe + yoe / 4 - yoe / 100);
    let mp = (5 * doy + 2) / 153;
    let d = doy - (153 * mp + 2) / 5 + 1;
    let mo = if mp < 10 { mp + 3 } else { mp - 9 };
    let y = if mo <= 2 { y + 1 } else { y };
    format!("{y:04}-{mo:02}-{d:02} {h:02}:{min:02}:{s:02} UTC")
}

// ═══════════════════════════════════════════════════════════════════
// Multi-client detection
// ═══════════════════════════════════════════════════════════════════

fn detect_all_memory_dirs() -> Vec<ClientDir> {
    let home = match std::env::var("HOME").ok().map(PathBuf::from) {
        Some(h) => h,
        None => return vec![],
    };

    let candidates = [
        ("Claude Code", home.join(".claude").join("memory"), "IDENTITY_CONTEXT.md"),
        ("Cursor", home.join(".cursor").join("memory"), "agentic-identity.md"),
        ("Windsurf", home.join(".windsurf").join("memory"), "agentic-identity.md"),
        ("Cody", home.join(".sourcegraph").join("cody").join("memory"), "agentic-identity.md"),
    ];

    let mut dirs = Vec::new();
    for (name, memory_dir, filename) in &candidates {
        if create_if_parent_exists(memory_dir) {
            dirs.push(ClientDir {
                name,
                dir: memory_dir.clone(),
                filename: filename.to_string(),
            });
        }
    }
    dirs
}

fn create_if_parent_exists(memory_dir: &Path) -> bool {
    if memory_dir.exists() {
        return true;
    }
    if let Some(parent) = memory_dir.parent() {
        if parent.exists() {
            return std::fs::create_dir_all(memory_dir).is_ok();
        }
    }
    false
}

fn atomic_write(target: &Path, content: &[u8]) -> Result<(), std::io::Error> {
    let tmp = target.with_extension("tmp");
    let mut f = std::fs::File::create(&tmp)?;
    f.write_all(content)?;
    f.sync_all()?;
    std::fs::rename(&tmp, target)?;
    Ok(())
}
